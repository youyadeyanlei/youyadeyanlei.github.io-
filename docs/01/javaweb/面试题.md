## 面向对象的三大特征 封装，继承，多态

封装，我们写代码的时候，把代码的具体实现，实现的具体功能等细节隐藏起来，对外我们设置接口，就可以起到对程序的保护了

继承，我们写一些公共的父类，让子类来继承父类的对象属性和方法，子类拥有自己的方法和属性，也从父类哪里继承了父类的方法和属性，减少了代码的。。。

多态，同一种行为，不同对象产生了不同的结果

多态的三个条件，继承，重写，父类的引用指向子类对象，（？）

## 访问修饰符的级别

public》protected》default（默认）》private

## 对基本数据类型的了解

short s1=1； s1=s1+1；

java里面默认是整数类型是int ，s1=s1+1；报错,   s1+=1;正确

## 对于自动装箱127与128的理解

Integer a=128，b=128，c=127，d=127；

a==b ;   false

c==d;  true

Integer范围为-127到127，当为128的时候基本类型自动转换为包装类型，自动装箱，

所以a与b不是同一个对象，不相等；

## 对于String，String不是java的八大基本数据类型，String类不能被继承（被final修饰）八大基本数据类型，byte，short，int,long.float,double,char,boolean

  

## String 与StringBuilder 和StringBuffer的区别

String 被创建后，不能被修改，任何对string的修改都会引起	新的String对象生成

StringBuffer 跟String类似，但是值可以被修改，使用了synchronized来保证线程安全，效率低

StringBuilder 是StringBuffer 的线程非安全版本，没有使用synchronized，效率高

## String  s=new String("xyz")有几个对象产生

首先，如果在字符串常量池里面有xyz，就不需要在创建xyz对象（？），

但是，字符串常量池里没有，就会产生2个对象

## String s=“xyz”，String  s=new String("xyz")的区别

![image-20220830212720839](C:\Users\gu\AppData\Roaming\Typora\typora-user-images\image-20220830212720839.png)



## ==与equals的区别

简述几种情况下的equal与==

java基本类型
比较包装类型
比较String类型
比较对象
1.java基本类型（short，int，long，byte，char，float，double，boolean）

比较基本类型，只能用==，不能用equal，这里的==比较的是两个变量的值

2.比较包装类型

==比较的是内存地址，因为a和b是new出来的，是两个不同的对象，所以地址肯定是不同的，而equal比较的是值

3.比较[String类](https://so.csdn.net/so/search?q=String类&spm=1001.2101.3001.7020)型

==比较的是内存地址，equal比较的是值

4.比较对象

==和equal比较的都是内存地址，因为equal没有被重写，没有被重写的equal都是object的equal方法

## 两个对象的hashCode（）相同，则equals（）一定相为true吗？不一定

当a.equals(b) == true时，a.hashCode==b.hashCode(),一定成立

但是，a.hashCode==b.hashCode()，a.equals(b)  不一定为 true

## 什么是反射

我理解的反射是，通过在代码运行状态中，对于产生的字节码文件，我们可以调用或者改变字节码文件中产属性，方法，对象等等，

Java 反射，就是在运行状态中。

- 获取任意类的名称、package信息、所有属性、方法、注解、类型、类加载器等
- 获取任意对象的属性，并且能改变对象的属性
- 调用任意对象的方法
- 判断任意一个对象所属的类
- 实例化任意一个类的对象

反射有什么用，他使我们java能动态的进行操作，但是带来了一定的不安全性质

我们可以操作有访问权限限制的属性和方法

自定义注解

动态加载第三方的文件和jar包

实际的反射工作原理

当我们运行java程序的时候，每一个java文件都会被编译成为一个。class文件，这些class文件对象承载了，这个类的所有信息，包含，属性，方法，父类，构造器等待，

这些class文件在程序运行时会被classloader加载到虚拟机中。当一个类被加载的时候，java虚拟机就会在内存中创建一个class对象，我们可以通过对class对象进行操作，class类中的保护机制，访问权限，就相当于透明的了

反射主要借助classjava   constructor.java   method.java  field.java这四个类的程序运行时动态访问和修改类的行为和状态

## 浅拷贝和深拷贝的区别

分基本数据类型和引用数据类型

浅拷贝，对于基本数据类型，直接复制值，对于引用数据类型，只复制引用地址，当原来数据修改的时候，浅拷贝中的数据也跟着修改

深拷贝，对于基本数据类型，复制值，对于引用数据类型，开辟新的空间，在新的内存空间中复制一个一模一样的对象，新老对象不共享数据。



## 并发和并行的区别

并发，两个以上的事件在同一个时段发生

并行，两个以上的事件在同一时刻发生

并行，真正的在同一个时刻，做多件事情，

并发，在同一个时刻只会做一间事情，但是我们可以把时间分割成为时间碎片，交替进行，使人能感觉同一个时间段，多见事情同时在做

## 当一个对象被当作参数传递后，可以改变方法的属性和返回结果，是什么传递

，java中只有值传递，对于对象参数，值的内容是对象的引用。



## 重载和重写的区别

方法的重载和重写都是多态的表现形式

重载，一个类，有多个同名的方法，但是方法的参数列表不同，参数类型不同，参数个数不同

重写，发生在子类继承父类的时候，子类对父类的方法进行重写，参数不变，返回类型可以改变，子类可以通过重写父类的方法，实现自己特有的行为。

## 构造器是否能被重写

不能，构造器，不能被重写，但是可以被重载，一个类的构造器可以有多个。



## 为什么不能根据返回类型来区分重载

方法的返回值只能当成方法运行之后的一个状态，不是所以的方法都关注返回值，

int test（int a）

long test（int a）

### java静态变量和成员变量的区别

静态变量又称为类变量，static修饰

实列变量，又称为成员变量，没有static修饰

成员变量存在堆内存中。静态变量存在方法区中

成员变量与对象共同存亡，随着对象的创建而存在，当对象被销毁的时候，而被释放。静态变量与类共同存亡，随类的加载而存在，随类的消失而消失。

成员变量只能被对象调用。静态变量能被对象调用，也能被类调用。

### 是否可以从一个静态static方法内部发出对非静态方法的调用

分情况，

1.首先当实列对象没有被创建的时候，无法调用静态方法，非静态方法只能被对象调用，静态方法可以被类和对象调用，当静态方法被对象调用的时候，可能对象还没被创建。

2.显示创建对象的实例，可以发起调用，在静态方法中显示的创建对象实例，则可以通过正常的调用、



### 初始化考察

静态变量只会执行一次初始化

当有父类的时候，完整顺序

父类静态代码块（静态变量）>子类静态代码块（静态变量）>父类非静态变量（非静态代码块）>父类构造器>子类非静态变量（非静态代码块）>子类构造器



### 抽象类和接口有什么区别

1.抽象类只能单继承，接口可以多实现

2.抽象类可以有构造方法，接口中不能有构造方法

3.抽象类可以有成员变量，接口只能有常量默认的是public static final

待补

![image-20220905210540536](C:\Users\gu\AppData\Roaming\Typora\typora-user-images\image-20220905210540536.png)

理解，接口是自上而下的抽象，接口规范了某些行为，当我们需要这个行为的时候，我就去实现这个行为，具体怎么实现自己决定。

抽象类是，自下而上的抽象，当我们写代码的时候发现有一类行为，我们写的代码几乎相同，我们就把这类行为抽象出来，形成抽象类，如果有区别，我们提供抽象方法的自定义重写来实现。

### java中的final关键字有哪些用法

修饰类：该类不能再派生出新的子类，不能作为父类被继承。因此一个类不能同时被声明成为abstract和final

修饰方法，该方法不能被子类重写

修饰变量，该变量必须在声明时给定初始值，而且以后只能被读取，不能修改。如果变量是对象，引用不可以被修改，对象的属性值可以被修改



### final，finally，finalize的区别

final修饰类，方法，变量，表示最终的

finally是java异常处理机制的最后执行，在try，catch中，finally一定会执行，所以通常把释放资源，锁，数据库链接放在里面

finalize object中的方法，在垃圾收集器将对象从内存中清理出去之前做必要的清理工作。





### 对于try'、catch、finally 的运行结果

在try执行return前 会先执行finally语句块，如果finally中有return，就直接return了

在执行finally之前，JVM会先先将i变量的值存储起来，然后finally执行完毕以后，会返回之前存储的结果。从字节码文件可以看出finally之前，JVM会使用iload，istore两个指令，

将结果暂存，在最终返回时在通过iload，iretrun指令返回暂存的结果。



### Error和Exception有什么区别？

Error和Exception都是Throwable的子类，用于表示程序出现了不正常的情况。区别在与Error表示系统级错误，基本不是程序自己能处理了，所以标准处理，让开发人员发现，进行修改

Exception表示需要捕捉或者需要程序进行处理异常的情况，是程序在设计或者实现过程中出现了不必要，不正常的运行情况，需要进行处理异常，保证程序运行正常。





